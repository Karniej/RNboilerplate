patch-package
--- a/node_modules/babel-plugin-jest-hoist/build/index.js
+++ b/node_modules/babel-plugin-jest-hoist/build/index.js
@@ -1,5 +1,3 @@
-'use strict';
-
 /**
  * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
  *
@@ -11,7 +9,7 @@
 
 function invariant(condition, message) {
   if (!condition) {
-    throw new Error('babel-plugin-jest-hoist: ' + message);
+    throw new Error(`babel-plugin-jest-hoist: ${message}`);
   }
 }
 
@@ -22,6 +20,8 @@ const WHITELISTED_IDENTIFIERS = {
   Array: true,
   ArrayBuffer: true,
   Boolean: true,
+  console: true,
+  Console: true,
   DataView: true,
   Date: true,
   Error: true,
@@ -65,25 +65,28 @@ const WHITELISTED_IDENTIFIERS = {
   expect: true,
   jest: true,
   require: true,
-  undefined: true
+  undefined: true,
 };
-Object.keys(global).forEach(name => WHITELISTED_IDENTIFIERS[name] = true);
+Object.keys(global).forEach(name => (WHITELISTED_IDENTIFIERS[name] = true));
 
 const JEST_GLOBAL = { name: 'jest' };
 const IDVisitor = {
   ReferencedIdentifier(path) {
     this.ids.add(path);
   },
-  blacklist: ['TypeAnnotation']
+  blacklist: ['TypeAnnotation'],
 };
 
 const FUNCTIONS = Object.create(null);
-FUNCTIONS.mock = args => {
+FUNCTIONS.mock = (args) => {
   if (args.length === 1) {
     return args[0].isStringLiteral() || args[0].isLiteral();
   } else if (args.length === 2 || args.length === 3) {
     const moduleFactory = args[1];
-    invariant(moduleFactory.isFunction(), 'The second argument of `jest.mock` must be an inline function.');
+    invariant(
+      moduleFactory.isFunction(),
+      'The second argument of `jest.mock` must be an inline function.',
+    );
 
     const ids = new Set();
     const parentScope = moduleFactory.parentPath.scope;
@@ -103,9 +106,19 @@ FUNCTIONS.mock = args => {
       }
 
       if (!found) {
-        invariant(scope.hasGlobal(name) && WHITELISTED_IDENTIFIERS[name] || /^mock/.test(name) ||
-        // Allow istanbul's coverage variable to pass.
-        /^(?:__)?cov/.test(name), 'The module factory of `jest.mock()` is not allowed to ' + 'reference any out-of-scope variables.\n' + 'Invalid variable access: ' + name + '\n' + 'Whitelisted objects: ' + Object.keys(WHITELISTED_IDENTIFIERS).join(', ') + '.\n' + 'Note: This is a precaution to guard against uninitialized mock ' + 'variables. If it is ensured that the mock is required lazily, ' + 'variable names prefixed with `mock` are permitted.');
+        invariant(
+          (scope.hasGlobal(name) && WHITELISTED_IDENTIFIERS[name]) ||
+            /^mock/.test(name) ||
+            // Allow istanbul's coverage variable to pass.
+            /^(?:__)?cov/.test(name),
+          `${'The module factory of `jest.mock()` is not allowed to ' +
+            'reference any out-of-scope variables.\n' +
+            'Invalid variable access: '}${name}\n` +
+            `Whitelisted objects: ${Object.keys(WHITELISTED_IDENTIFIERS).join(', ')}.\n` +
+            'Note: This is a precaution to guard against uninitialized mock ' +
+            'variables. If it is ensured that the mock is required lazily, ' +
+            'variable names prefixed with `mock` are permitted.',
+        );
       }
     }
 
@@ -120,8 +133,10 @@ FUNCTIONS.deepUnmock = args => args.length === 1 && args[0].isStringLiteral();
 FUNCTIONS.disableAutomock = FUNCTIONS.enableAutomock = args => args.length === 0;
 
 module.exports = () => {
-  const isJest = callee => callee.get('object').isIdentifier(JEST_GLOBAL) || callee.isMemberExpression() && isJest(callee.get('object'));
-  const shouldHoistExpression = expr => {
+  const isJest = callee =>
+    callee.get('object').isIdentifier(JEST_GLOBAL) ||
+    (callee.isMemberExpression() && isJest(callee.get('object')));
+  const shouldHoistExpression = (expr) => {
     if (!expr.isCallExpression()) {
       return false;
     }
@@ -129,7 +144,13 @@ module.exports = () => {
     const callee = expr.get('callee');
     const object = callee.get('object');
     const property = callee.get('property');
-    return property.isIdentifier() && FUNCTIONS[property.node.name] && (object.isIdentifier(JEST_GLOBAL) || callee.isMemberExpression() && shouldHoistExpression(object)) && FUNCTIONS[property.node.name](expr.get('arguments'));
+    return (
+      property.isIdentifier() &&
+      FUNCTIONS[property.node.name] &&
+      (object.isIdentifier(JEST_GLOBAL) ||
+        (callee.isMemberExpression() && shouldHoistExpression(object))) &&
+      FUNCTIONS[property.node.name](expr.get('arguments'))
+    );
   };
   return {
     visitor: {
@@ -137,7 +158,7 @@ module.exports = () => {
         if (shouldHoistExpression(path.get('expression'))) {
           path.node._blockHoist = Infinity;
         }
-      }
-    }
+      },
+    },
   };
 };
